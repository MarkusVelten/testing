#ifndef MEPHISTO_DETAIL_META
#define MEPHISTO_DETAIL_META
#include <mephisto/algorithm/copy>

namespace mephisto {
namespace detail {

/**
 * Information about a local chunk of memory and its coordinates relative to
 * the global origin.
 */
template <
    typename PatternT>
struct Metadata {
    typedef typename PatternT::index_type OffsetT;
    typedef typename PatternT::size_type ExtentsT;

    // Offset at first element
    OffsetT  offset;
    // Extents of the chunk
    ExtentsT localExtents;
    size_t chunk_size;

    Metadata(OffsetT offset, ExtentsT localExtents) : offset(offset), localExtents(localExtents) {
        // Calculate the chunk size once
        chunk_size = 1;
        for(auto i : localExtents) {
            chunk_size *= i;
        }
    }

    template<
        typename IndexT>
    ALPAKA_FN_HOST_ACC IndexT global_coords(OffsetT localOffset) {
    }
};

/**
 * Data buffer is used to reduce the number of parameters to avoid hitting the 256 byte
 * limit.
 *
 * buf[[meta]..<padding>..[data...]]
 *  
 */
template <
    typename ElementT,
    typename DeviceT,
    typename MetaT,
    typename Alignment =
        typename alpaka::core::align::OptimalAlignment<sizeof(ElementT)>::type>
struct DataBuffer {
    static constexpr size_t MetaOffset = sizeof(MetaT) + sizeof(MetaT) % Alignment::value;

    char *data;

    template<
        typename ViewT>
    DataBuffer(DeviceT dev, ViewT &view) {
        auto bufsize = sizeof(MetaT) + view.size() * sizeof(ElementT) + Alignment::value;
        auto alpakaBuf = alpaka::mem::buf::alloc<char, decltype(bufsize)>(dev, bufsize);
        auto buf = alpaka::mem::view::getPtrNative(alpakaBuf);

        data = buf + MetaOffset;

        new (buf) MetaT(view.pattern().global(view.lbegin()), view.pattern().extents()); 

        mephisto::copy(view, data);
    }
    MetaT& getMeta() {
        return reinterpret_cast<MetaT>(data - MetaOffset);
    }


    ElementT *getData() {
        return data;
    }

    // dtor needs device?
};
}
}

#endif

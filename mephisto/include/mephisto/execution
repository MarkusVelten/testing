#ifndef MEPHISTO_EXECUTION
#define MEPHISTO_EXECUTION


#include <alpaka/alpaka.hpp>
#include <libdash.h>
#include <experimental/execution>
#include <mephisto/buffer>
#include <mephisto/algorithm/copy>
#include <mephisto/algorithm/for_each>

namespace mephisto {
namespace execution {


using std::experimental::execution::executor_shape;

/**
 * An executor that uses alpaka to do the work.
 */
template<class AlpakaContext, class PatternT>
struct AlpakaExecutor {
    AlpakaContext ctx;

    // e.g. std::array<3> for 3 dimensions
    using index_type = typename PatternT::index_type;
    // e.g. std::array<3> for 3 dimensions
    /* using shape_type = std::tuple<PatternT, dash::LocalRange<ElementT>, dash::LocalIndexRange<index_type>>; */
    using Acc = typename AlpakaContext::acc_t;
    using SizeT = typename PatternT::size_type;

    AlpakaExecutor(AlpakaContext context)
      : ctx(context)
    {
    }

    template <class Function, class Shape, class SharedState>
    void bulk_execute(
        Function executorFunc,
        Shape       shape,
        SharedState state)
    {

        // ---------------------------------------------
        // Copy data to the accelerator
        // ---------------------------------------------
        //
        auto local_range = std::get<1>(shape);
        // TODO: make this less ugly
        using ElementT = typename std::remove_reference<decltype(*(local_range.begin))>::type;
        // local one dimensional index range
        auto local_index = std::get<2>(shape);
        // number of elements in local memory block
        SizeT nelems = local_index.end - local_index.begin;
        assert(nelems >= 0);

        alpaka::vec::Vec<alpaka::dim::DimInt<1u>, SizeT> const extent(nelems);

        alpaka::workdiv::WorkDivMembers<alpaka::dim::DimInt<1u>, SizeT> const
            workDiv(alpaka::workdiv::getValidWorkDiv<Acc>(
                ctx.accDevice,
                extent,
                static_cast<SizeT>(1u),
                false,
                alpaka::workdiv::GridBlockExtentSubDivRestrictions::
                    Unrestricted));

        // create the host buffer
        auto hostBuf = mephisto::HostDataBuffer<
            ElementT,
            AlpakaContext,
            PatternT,
            dash::LocalRange<ElementT>>(ctx, local_range);


        mephisto::put(ctx.stream, hostBuf);

        // get the buffer on the device
        auto deviceBuf = hostBuf.getDeviceDataBuffer();

	// TODO: extract
	ForEachKernel<Function> kernel;

        auto sharedState(state());
        auto const forEach(alpaka::exec::create<Acc>(
            workDiv,
            kernel,
            deviceBuf.begin(),
            nelems));

        alpaka::stream::enqueue(ctx.stream, forEach);
    }

    template<class Policy>
    AlpakaExecutor require(Policy &) {
        return *this;
    }

    AlpakaContext &context()
    {
        return ctx;
    }
};


template <class AccT, class HostDevice, class AccDevice, class Stream>
struct AlpakaExecutionContext {
    using host_t = typename std::remove_cv<HostDevice>::type;
    using device_t = typename std::remove_cv<AccDevice>::type;
    using acc_t = AccT;

    HostDevice &hostDevice;
    AccDevice & accDevice;
    Stream &    stream;

    AlpakaExecutionContext(HostDevice &host, AccDevice &acc, Stream &stream)
      : hostDevice(host)
      , accDevice(acc)
      , stream(stream)
    {
    }
};

template <class AccT, class HostDevice, class AccDevice, class Stream>
AlpakaExecutionContext<AccT, HostDevice, AccDevice, Stream> make_context(
    HostDevice &host, AccDevice &acc, Stream &stream)
{
    return AlpakaExecutionContext<AccT, HostDevice, AccDevice, Stream>(
        host, acc, stream);
}

template <class AlpakaContext, class Pattern>
AlpakaExecutor<AlpakaContext, Pattern> make_executor(
    AlpakaContext context, Pattern)
{
    return AlpakaExecutor<AlpakaContext, Pattern>(context);
}

// See C++17's std::execution::par
// Additionally we enforce that the policy has an executor
template<class Executor>
struct ParallelPolicy {
    Executor ex;

    ParallelPolicy(Executor ex) : ex(ex) {}

    const Executor &executor() const {
        return ex;
    }
};

template <class Executor>
ParallelPolicy<Executor> make_parallel_policy(Executor ex)
{
    return ParallelPolicy<Executor>(ex);
}
}
}

#endif

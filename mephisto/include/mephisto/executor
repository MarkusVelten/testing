
namespace mephisto {
namespace execution {

template <class HostDevice, class AccDevice, class Stream>
struct AlpakaExecutionContext {
    HostDevice &hostDevice;
    AccDevice & accDevice;
    Stream &    stream;

    AlpakaExecutionContext(
        HostDevice &host, AccDevice &acc, Stream &stream)
      : hostDevice(host)
      , accDevice(acc)
      , stream(stream)
    {
    }
};

template <class HostDevice, class AccDevice, class Stream>
AlpakaExecutionContext<HostDevice, AccDevice, Stream> make_context(
    HostDevice &host, AccDevice &acc, Stream &stream)
{
    return AlpakaExecutionContext<HostDevice, AccDevice, Stream>(
        host, acc, stream);
}

/**
 * An executor that uses alpaka to do the work.
 */
template<class AlpakaContext>
struct AlpakaExecutor {
    AlpakaContext ctx;

    AlpakaExecutor(AlpakaContext context)
      : ctx(context)
    {
    }

    template <class Function, class SharedState>
    void bulk_execute(Function func, executor_shape<Executor>::type shape, SharedState state)
    {
        auto sharedState(state());
        for (size_t i = 0; i < n; ++i) {
            func(i, sharedState);
        }
    }

    template<class Policy>
    AlpakaExecutor require(Policy &) {
        return *this;
    }

    AlpakaContext &context()
    {
        return ctx;
    }
};

template <class AlpakaContext>
AlpakaExecutor<AlpakaContext> make_executor(AlpakaContext context)
{
    return AlpakaExecutor<AlpakaContext>(context);
}

// See C++17's std::execution::par
// Additionally we enforce that the policy has an executor
template<class Executor>
struct ParallelPolicy {
    Executor ex;

    ParallelPolicy(Executor ex) : ex(ex) {}

    const Executor &executor() const {
        return ex;
    }
};

template <class Executor>
ParallelPolicy<Executor> make_parallel_policy(Executor ex)
{
    return ParallelPolicy<Executor>(ex);
}

}
}
